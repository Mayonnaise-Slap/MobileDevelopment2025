# Отчет по лабораторной работе №2


## Цели работы

Цель данной лабораторной работы — сравнение трех подходов к параллельному программированию
в Python: `threading`, `multiprocessing` и `asyncio`, их особенностей, преимуществ и
ограничений, на двух задачах:

1. Подсчет суммы чисел от 1 до 10 триллионов.
2. Параллельный парсинг (запросы к API) с сохранением в базу данных.

---

## Задача 1: Подсчет суммы от 1 до 10000000000000

### Подходы:

* **Threading** — использует потоки и совместное использование памяти.
* **Multiprocessing** — использует независимые процессы с отдельной памятью.
* **Asyncio** — реализует неблокирующую асинхронность на событийном цикле.

### Методика:

* Диапазон суммы был разбит на равные отрезки (например, по количеству потоков/процессов).
* Каждая подзадача считает частичную сумму.
* Итоговая сумма собирается после выполнения всех задач.
* Использовался модуль `time` для замеров.

### Результаты замеров времени (в секундах):

| Метод             | Время (сек) | Комментарий                                |
|-------------------|-------------|--------------------------------------------|
| `threading`       | 140         | Многоядерность не используется; GIL мешает |
| `multiprocessing` | 26.81       | Эффективная загрузка всех ядер             |
| `asyncio`         | 163         | Неэффективен для CPU-bound задач           |
| `sum(range())`    | 193         | Последовательное выполнение                |

### Вывод по задаче 1:

* `multiprocessing` показал **лучший результат**, так как CPU-bound задачи (подсчет суммы)
  выигрывают от параллелизма на уровне процессов.
* `threading` ограничен GIL и хуже подходит для вычислений.
* `asyncio` не предназначен для тяжелых вычислений и даже уступает `threading`.
* Все подходы оказались быстрее наивного подхода

---

## Задача 2: Параллельный парсинг (запросы к API) и сохранение в БД

### Подходы:

* Все реализации выполняли HTTP-запросы (по API), сохраняли данные в Postgres.
  Асинхронная версия использовала асинхронный движок, остальные - синхронный

### Методика:

* Использовался рекурсивных проход по сущностям в api.
* Для контроля за количеством одновременно исполняемых запросов использовался семафор
* Время замерялось на полный проход запросов + сохранение.
* Асинхронную реализацию не удалось замерить по времени.

### Результаты замеров времени (в секундах):

| Метод             | Время (сек) | Комментарий                     |
|-------------------|-------------|---------------------------------|
| `threading`       | 22          | Умеренно эффективно при I/O     |
| `multiprocessing` | 18.5        | Быстрее, но сложнее координация |
| `asyncio`         | —           | Не замерено                     |

### Вывод по задаче 2:

* В I/O-bound задачах выигрывают `asyncio` и `threading`.
* `multiprocessing` незначительно быстрее, но неэффективен по памяти.
* Ожидается, что **async** показал бы **наилучшее время**, т.к. создан именно для
  I/O-задач.

---

## Сравнительная таблица подходов

| Подход            | Поддержка параллелизма     | Лучшее для       | Минусы                            |
|-------------------|----------------------------|------------------|-----------------------------------|
| `threading`       | Псевдопараллельность (GIL) | I/O-bound задачи | Неэффективен для CPU-bound        |
| `multiprocessing` | Настоящий параллелизм      | CPU-bound задачи | Высокие накладные расходы, память |
| `asyncio`         | Асинхронность (1 поток)    | I/O-bound задачи | Не работает с CPU-bound           |

---

## Заключение

* **Для тяжелых вычислений**: `multiprocessing` — оптимальный выбор.
* **Для операций с сетью/API**: `asyncio` или `threading` — лучшие кандидаты, при этом
  `asyncio` предпочтительнее.
* **threading** может быть компромиссным решением, но GIL ограничивает его
  масштабируемость.
